"""Compliance/audit checks for Mist site configuration."""

from __future__ import annotations

import ast
import copy
import json
import re
import warnings
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, Iterable, List, Mapping, Optional, Sequence, Set, Tuple

from audit_actions import AP_RENAME_ACTION_ID, CLEAR_DNS_OVERRIDE_ACTION_ID


@dataclass
class SiteContext:
    """Bundle of site-related data used when evaluating compliance checks."""

    site_id: str
    site_name: str
    site: Dict[str, Any] = field(default_factory=dict)
    setting: Dict[str, Any] = field(default_factory=dict)
    templates: Sequence[Dict[str, Any]] = field(default_factory=list)
    devices: Sequence[Dict[str, Any]] = field(default_factory=list)


@dataclass
class Finding:
    """A single non-compliant item detected by a check."""

    site_id: str
    site_name: str
    message: str
    severity: Optional[str] = None
    device_id: Optional[str] = None
    device_name: Optional[str] = None
    details: Optional[Dict[str, Any]] = None
    actions: Optional[List[Dict[str, Any]]] = None

    def as_dict(self, default_severity: str) -> Dict[str, Any]:
        data: Dict[str, Any] = {
            "site_id": self.site_id,
            "site_name": self.site_name,
            "message": self.message,
            "severity": self.severity or default_severity,
        }
        if self.device_id:
            data["device_id"] = self.device_id
        if self.device_name:
            data["device_name"] = self.device_name
        if self.details is not None:
            data["details"] = self.details
        if self.actions:
            data["actions"] = self.actions
        return data


class ComplianceCheck:
    """Base class for checks that can be executed against a site."""

    id: str = ""
    name: str = ""
    description: str = ""
    severity: str = "warning"

    def prepare_run(self) -> None:  # pragma: no cover - hook
        """Reset any stateful data prior to executing across all sites."""

    def run(self, context: SiteContext) -> List[Finding]:  # pragma: no cover - interface
        raise NotImplementedError

    def suggest_actions(
        self,
        contexts: Sequence[SiteContext],
        findings: Sequence[Finding],
    ) -> List[Dict[str, Any]]:  # pragma: no cover - hook
        """Return optional auto-remediation actions for the given findings."""
        return []


def _normalize_site_name(site: Dict[str, Any]) -> str:
    for key in ("name", "site_name", "display_name"):
        value = site.get(key)
        if isinstance(value, str) and value.strip():
            return value
    return site.get("id") or ""


def _collect_site_variables(context: SiteContext) -> Dict[str, Any]:
    candidates: List[Dict[str, Any]] = []
    for container in (context.site, context.setting):
        if not isinstance(container, dict):
            continue
        for key in ("variables", "vars", "site_vars", "site_variables"):
            value = container.get(key)
            if isinstance(value, dict):
                candidates.append(value)
    merged: Dict[str, Any] = {}
    for candidate in candidates:
        merged.update({k: v for k, v in candidate.items() if isinstance(k, str)})
    return merged


def _load_compliance_rules_doc() -> Dict[str, Any]:
    data = None
    if COMPLIANCE_RULES_PATH.exists():
        try:
            data = json.loads(COMPLIANCE_RULES_PATH.read_text(encoding="utf-8"))
        except Exception:
            data = None
    if data is None and COMPLIANCE_RULES_SAMPLE_PATH.exists():
        try:
            data = json.loads(COMPLIANCE_RULES_SAMPLE_PATH.read_text(encoding="utf-8"))
        except Exception:
            data = None
    return data if isinstance(data, dict) else {}


def _normalize_logic_conditions(conditions: Iterable[Dict[str, Any]]) -> List[Dict[str, str]]:
    cleaned: List[Dict[str, str]] = []
    for entry in conditions:
        if not isinstance(entry, dict):
            continue
        join = str(entry.get("join", "and")).strip().lower()
        if join not in {"and", "or"}:
            join = "and"
        field = str(entry.get("field", "")).strip()
        operator = str(entry.get("operator", "")).strip()
        expected_value = str(entry.get("expected_value", "")).strip()
        if not field or not operator:
            continue
        cleaned.append(
            {
                "join": join,
                "field": field,
                "operator": operator,
                "expected_value": expected_value,
            }
        )
    return cleaned


def _load_logic_rules() -> List[Dict[str, Any]]:
    doc = _load_compliance_rules_doc()
    logic_raw = doc.get("logic_rules")
    if not isinstance(logic_raw, list):
        return []
    cleaned_rules: List[Dict[str, Any]] = []
    for item in logic_raw:
        if not isinstance(item, dict):
            continue
        platform = str(item.get("platform", "")).strip().lower() or "mist"
        scope = str(item.get("scope", "")).strip().lower()
        if scope not in {"org", "site", "device"}:
            scope = "site"
        name = str(item.get("name", "")).strip()
        action_id = str(item.get("action_id", "")).strip()
        action_label = str(item.get("action_label", "")).strip()
        action_path = str(item.get("action_path", "")).strip()
        conditions = _normalize_logic_conditions(item.get("conditions") or [])
        if not conditions:
            continue
        cleaned_rules.append(
            {
                "platform": platform,
                "scope": scope,
                "name": name,
                "action_id": action_id,
                "action_label": action_label,
                "action_path": action_path,
                "conditions": conditions,
            }
        )
    return cleaned_rules


DEFAULT_REQUIRED_SITE_VARIABLES: Tuple[str, ...] = (
    "hubradiusserver",
    "localradiusserver",
    "siteDNS",
    "hubDNSserver1",
    "hubDNSserver2",
)

COMPLIANCE_RULES_PATH = Path(__file__).resolve().parent / "compliance_rules.json"
COMPLIANCE_RULES_SAMPLE_PATH = Path(__file__).resolve().parent / "compliance_rules.sample.json"


def _load_compliance_rule_map() -> Dict[str, str]:
    data = None
    if COMPLIANCE_RULES_PATH.exists():
        try:
            data = json.loads(COMPLIANCE_RULES_PATH.read_text(encoding="utf-8"))
        except Exception:
            data = None
    if data is None and COMPLIANCE_RULES_SAMPLE_PATH.exists():
        try:
            data = json.loads(COMPLIANCE_RULES_SAMPLE_PATH.read_text(encoding="utf-8"))
        except Exception:
            data = None
    if data is None:
        return {}

    if not isinstance(data, dict):
        return {}

    rules = data.get("rules")
    if not isinstance(rules, list):
        return {}

    mapped: Dict[str, str] = {}
    for item in rules:
        if not isinstance(item, dict):
            continue
        name = str(item.get("name") or "").strip()
        if not name:
            continue
        value = item.get("value")
        if value is None:
            mapped[name] = ""
        elif isinstance(value, str):
            mapped[name] = value
        else:
            mapped[name] = str(value)
    return mapped


def _load_compliance_rule_value(rule_name: str) -> Optional[str]:
    rules = _load_compliance_rule_map()
    if rule_name in rules:
        return rules[rule_name]
    return None


def _parse_expected_value(value: str) -> Any:
    cleaned = str(value or "").strip()
    if not cleaned:
        return ""
    try:
        return ast.literal_eval(cleaned)
    except Exception:
        return cleaned


def _extract_field_value(payload: Mapping[str, Any], field_path: str) -> Any:
    if not field_path:
        return None
    if field_path in payload:
        return payload.get(field_path)
    current: Any = payload
    for key in field_path.split("."):
        if isinstance(current, Mapping) and key in current:
            current = current[key]
        else:
            return None
    return current


def _is_empty_value(value: Any) -> bool:
    if value is None:
        return True
    if isinstance(value, str):
        return not value.strip()
    if isinstance(value, (list, tuple, set, dict)):
        return len(value) == 0
    return False


def _values_equal(actual: Any, expected: Any) -> bool:
    if actual is None:
        return expected is None or expected == ""
    if isinstance(actual, (int, float, bool, str)) and isinstance(expected, (int, float, bool, str)):
        return actual == expected
    return str(actual) == str(expected)


def _coerce_number(value: Any) -> Optional[float]:
    if isinstance(value, bool):
        return float(value)
    if isinstance(value, (int, float)):
        return float(value)
    if isinstance(value, str):
        try:
            return float(value.strip())
        except ValueError:
            return None
    return None


def _contains_value(actual: Any, expected: Any) -> bool:
    if actual is None:
        return False
    if isinstance(expected, (list, tuple, set)):
        if isinstance(actual, (list, tuple, set)):
            actual_values = {str(item) for item in actual}
            return any(str(item) in actual_values for item in expected)
        return actual in expected or str(actual) in {str(item) for item in expected}
    if isinstance(actual, str):
        return str(expected) in actual
    if isinstance(actual, Mapping):
        return str(expected) in {str(k) for k in actual.keys()}
    if isinstance(actual, (list, tuple, set)):
        return expected in actual or str(expected) in {str(item) for item in actual}
    return str(expected) in str(actual)


def _evaluate_conditions(conditions: Sequence[Mapping[str, str]], payload: Mapping[str, Any]) -> bool:
    if not conditions:
        return False
    result: Optional[bool] = None
    for idx, condition in enumerate(conditions):
        operator = str(condition.get("operator", "")).strip()
        field = str(condition.get("field", "")).strip()
        expected_raw = str(condition.get("expected_value", "")).strip()
        expected = _parse_expected_value(expected_raw)
        actual = _extract_field_value(payload, field)
        if operator == "equals":
            passed = _values_equal(actual, expected)
        elif operator == "not_equals":
            passed = not _values_equal(actual, expected)
        elif operator == "contains":
            passed = _contains_value(actual, expected)
        elif operator == "not_contains":
            passed = not _contains_value(actual, expected)
        elif operator == "matches":
            if actual is None:
                passed = False
            else:
                try:
                    passed = bool(re.fullmatch(str(expected), str(actual)))
                except re.error:
                    passed = False
        elif operator == "not_matches":
            if actual is None:
                passed = False
            else:
                try:
                    passed = not bool(re.fullmatch(str(expected), str(actual)))
                except re.error:
                    passed = False
        elif operator == "greater_than":
            actual_num = _coerce_number(actual)
            expected_num = _coerce_number(expected)
            passed = actual_num is not None and expected_num is not None and actual_num > expected_num
        elif operator == "less_than":
            actual_num = _coerce_number(actual)
            expected_num = _coerce_number(expected)
            passed = actual_num is not None and expected_num is not None and actual_num < expected_num
        elif operator == "is_empty":
            passed = _is_empty_value(actual)
        elif operator == "is_not_empty":
            passed = not _is_empty_value(actual)
        else:
            passed = False
        if result is None:
            result = passed
        else:
            join = str(condition.get("join", "and")).strip().lower()
            if join == "or":
                result = result or passed
            else:
                result = result and passed
        if result is False and idx < len(conditions) - 1:
            continue
    return bool(result)


def _build_site_payload(context: SiteContext) -> Dict[str, Any]:
    payload: Dict[str, Any] = {}
    if isinstance(context.site, Mapping):
        payload.update(context.site)
    if isinstance(context.setting, Mapping):
        payload.update(context.setting)
    if context.site_name:
        payload.setdefault("site_name", context.site_name)
    site_variables = _collect_site_variables(context)
    payload["site_variables"] = site_variables
    template_names = sorted(_collect_template_names(context))
    payload["template_names"] = template_names
    payload["template_name_count"] = len(template_names)
    site_override_paths = sorted(_collect_override_paths(context.setting))
    payload["site_override_paths"] = site_override_paths
    payload["site_override_count"] = len(site_override_paths)
    return payload


def _build_device_payload(context: SiteContext, device: Mapping[str, Any]) -> Dict[str, Any]:
    payload: Dict[str, Any] = dict(device)
    if context.site_name:
        payload.setdefault("site_name", context.site_name)
    device_name = (
        device.get("name")
        or device.get("hostname")
        or device.get("device_name")
        or device.get("mac")
        or device.get("id")
    )
    if isinstance(device_name, str) and device_name.strip():
        payload.setdefault("device_name", device_name.strip())
    payload["is_switch"] = _is_switch(device)
    payload["is_access_point"] = _is_access_point(device)
    payload["firmware_version"] = _extract_firmware_version(device) or ""
    payload["image_count"] = len(_collect_device_images(dict(device)))
    device_override_paths = sorted(_collect_override_paths(device))
    payload["device_override_paths"] = device_override_paths
    payload["device_override_count"] = len(device_override_paths)
    port_overrides = _collect_port_overrides(dict(device))
    payload["port_override_count"] = len(port_overrides)
    return payload


def _load_site_variable_list(var_name: str, default: Sequence[str]) -> Tuple[str, ...]:
    raw = _load_compliance_rule_value(var_name)
    if raw is None:
        return tuple(default)
    candidate = raw.strip()
    if not candidate:
        return tuple(default)
    values = [item.strip() for item in candidate.split(",")]
    filtered = [value for value in values if value]
    return tuple(filtered or default)


def _load_version_list_from_rules(var_name: str) -> Tuple[str, ...]:
    raw = _load_compliance_rule_value(var_name)
    if raw is None:
        return ()
    candidate = raw.strip()
    if not candidate:
        return ()
    values = [item.strip() for item in candidate.split(",")]
    return tuple(value for value in values if value)


class RequiredSiteVariablesCheck(ComplianceCheck):
    id = "required_site_variables"
    name = "Required site variables"
    description = "Ensure required Mist site variables are defined."
    severity = "error"

    def __init__(self, required_keys: Optional[Sequence[str]] = None) -> None:
        default_keys = _load_site_variable_list("MIST_SITE_VARIABLES", DEFAULT_REQUIRED_SITE_VARIABLES)
        if required_keys is None:
            self.required_keys: Tuple[str, ...] = tuple(default_keys)
        else:
            self.required_keys = tuple(required_keys)

    def run(self, context: SiteContext) -> List[Finding]:
        findings: List[Finding] = []
        variables = _collect_site_variables(context)
        missing = [key for key in self.required_keys if key not in variables or variables.get(key) in (None, "")]
        for key in missing:
            findings.append(
                Finding(
                    site_id=context.site_id,
                    site_name=context.site_name,
                    message=f"Site variable '{key}' is not defined.",
                )
            )
        return findings


def _collect_template_names(context: SiteContext) -> Set[str]:
    names: Set[str] = set()
    for container in (context.site, context.setting):
        if not isinstance(container, dict):
            continue
        for key in ("networktemplate_name", "network_template_name", "template_name"):
            value = container.get(key)
            if isinstance(value, str) and value.strip():
                names.add(value)
    for tmpl in context.templates:
        if not isinstance(tmpl, dict):
            continue
        for key in ("name", "template_name"):
            value = tmpl.get(key)
            if isinstance(value, str) and value.strip():
                names.add(value)
    return names


def _collect_template_ids(context: SiteContext) -> Set[str]:
    ids: Set[str] = set()
    for container in (context.site, context.setting):
        if not isinstance(container, dict):
            continue
        for key in (
            "networktemplate_id",
            "network_template_id",
            "template_id",
            "switch_template_id",
        ):
            value = container.get(key)
            if isinstance(value, str) and value.strip():
                ids.add(value)
    for tmpl in context.templates:
        if not isinstance(tmpl, dict):
            continue
        for key in ("id", "template_id"):
            value = tmpl.get(key)
            if isinstance(value, str) and value.strip():
                ids.add(value)
    return ids


def _resolve_device_template_id(device: Mapping[str, Any]) -> Optional[str]:
    for key in ("template_id", "switch_template_id"):
        value = device.get(key)
        if isinstance(value, str) and value.strip():
            return value
    return None


def _site_is_lab(site_name: Optional[str]) -> bool:
    if not site_name:
        return False
    return "lab" in site_name.lower()


def _format_dns_var_group_label(options: Sequence[str]) -> str:
    labels = [opt for opt in options if isinstance(opt, str) and opt]
    if not labels:
        return ""
    if len(labels) == 1:
        return labels[0]
    if len(labels) == 2:
        return f"{labels[0]} or {labels[1]}"
    return ", ".join(labels[:-1]) + f", or {labels[-1]}"


def _evaluate_dns_variable_groups(variables: Mapping[str, Any]) -> Tuple[bool, List[str]]:
    missing: List[str] = []
    for group in DNS_OVERRIDE_REQUIRED_VAR_GROUPS:
        if not any(_has_value(variables.get(name)) for name in group):
            label = _format_dns_var_group_label(group)
            if label:
                missing.append(label)
    return (not missing, missing)


def _expected_template_details(site_name: Optional[str]) -> Dict[str, Any]:
    is_lab = _site_is_lab(site_name)
    if is_lab:
        allowed_names = [
            name
            for name in (
                DNS_OVERRIDE_LAB_TEMPLATE_NAME,
                DNS_OVERRIDE_TEMPLATE_NAME,
            )
            if isinstance(name, str) and name
        ]
        allowed_ids: Tuple[str, ...] = tuple(
            dict.fromkeys(
                value
                for value in (
                    *(DNS_OVERRIDE_LAB_TEMPLATE_IDS or ()),
                    *(DNS_OVERRIDE_PROD_TEMPLATE_IDS or ()),
                )
                if isinstance(value, str) and value
            )
        )
        preferred = DNS_OVERRIDE_LAB_TEMPLATE_NAME or (allowed_names[0] if allowed_names else "")
    else:
        allowed_names = [
            name
            for name in (
                DNS_OVERRIDE_TEMPLATE_NAME,
            )
            if isinstance(name, str) and name
        ]
        allowed_ids = tuple(
            dict.fromkeys(
                value
                for value in (DNS_OVERRIDE_PROD_TEMPLATE_IDS or ())
                if isinstance(value, str) and value
            )
        )
        preferred = DNS_OVERRIDE_TEMPLATE_NAME
    return {
        "site_type": "lab" if is_lab else "production",
        "allowed_template_names": tuple(allowed_names),
        "allowed_template_ids": allowed_ids,
        "preferred_template_name": preferred,
    }


def _template_matches_requirements(
    template_names: Set[str],
    template_ids: Set[str],
    allowed_names: Sequence[str],
    allowed_ids: Sequence[str],
    device_template_id: Optional[str],
) -> bool:
    normalized_allowed_names = {name for name in allowed_names if isinstance(name, str) and name}
    normalized_allowed_ids = {tid for tid in allowed_ids if isinstance(tid, str) and tid}

    if device_template_id:
        value = device_template_id.strip()
        if value and value in normalized_allowed_ids:
            return True

    if normalized_allowed_ids and template_ids.intersection(normalized_allowed_ids):
        return True

    if normalized_allowed_names and template_names.intersection(normalized_allowed_names):
        return True

    return False


def _format_template_precheck_message(allowed_names: Sequence[str]) -> str:
    filtered = [name for name in allowed_names if isinstance(name, str) and name]
    if not filtered:
        return "Required switch template is not applied to this site."
    if len(filtered) == 1:
        return f"Apply '{filtered[0]}' template to this site."
    if len(filtered) == 2:
        return f"Apply '{filtered[0]}' or '{filtered[1]}' template to this site."
    joined = ", ".join(f"'{name}'" for name in filtered[:-1])
    return f"Apply one of these templates to this site: {joined}, or '{filtered[-1]}'."


class SwitchTemplateConfigurationCheck(ComplianceCheck):
    id = "switch_template_configuration"
    name = "Switch Template Configuration"
    description = (
        "Ensure lab sites use approved switch templates and non-lab sites remain on the production template."
    )
    severity = "warning"

    prod_template_name: str = "Prod - Standard Template"
    lab_template_name: str = "Test - Standard Template"

    def run(self, context: SiteContext) -> List[Finding]:
        template_names = _collect_template_names(context)
        if not template_names:
            return []

        site_name_upper = (context.site_name or "").upper()
        is_lab_site = "LAB" in site_name_upper
        findings: List[Finding] = []
        sorted_templates = ", ".join(sorted(template_names)) or "none"

        if is_lab_site:
            allowed = {self.prod_template_name, self.lab_template_name}
            if template_names.isdisjoint(allowed):
                findings.append(
                    Finding(
                        site_id=context.site_id,
                        site_name=context.site_name,
                        message=(
                            "Lab site should apply either "
                            f"'{self.prod_template_name}' or '{self.lab_template_name}' but current templates are: "
                            f"{sorted_templates}."
                        ),
                    )
                )
        else:
            if self.prod_template_name not in template_names:
                findings.append(
                    Finding(
                        site_id=context.site_id,
                        site_name=context.site_name,
                        message=(
                            f"Site should apply '{self.prod_template_name}' but current templates are: {sorted_templates}."
                        ),
                    )
                )
            extra_templates = template_names - {self.prod_template_name}
            if self.prod_template_name in template_names and extra_templates:
                findings.append(
                    Finding(
                        site_id=context.site_id,
                        site_name=context.site_name,
                        message=(
                            f"Site should not apply additional templates ({', '.join(sorted(extra_templates))}) when "
                            f"using '{self.prod_template_name}'."
                        ),
                    )
                )

        return findings


@dataclass
class OverrideEntry:
    path: str
    port_label: Optional[str] = None
    port_number: Optional[int] = None


def _collect_override_paths(data: Any, prefix: str = "") -> List[str]:
    paths: List[str] = []
    if isinstance(data, dict):
        for key, value in data.items():
            new_prefix = f"{prefix}.{key}" if prefix else key
            key_lower = key.lower()
            if "override" in key_lower and _has_value(value):
                paths.append(new_prefix)
                continue
            paths.extend(_collect_override_paths(value, new_prefix))
    elif isinstance(data, list):
        for idx, value in enumerate(data):
            new_prefix = f"{prefix}[{idx}]" if prefix else f"[{idx}]"
            paths.extend(_collect_override_paths(value, new_prefix))
    return paths


def _has_value(value: Any) -> bool:
    if value is None:
        return False
    if isinstance(value, (str, bytes)):
        return bool(str(value).strip())
    if isinstance(value, (list, tuple, set, dict)):
        return bool(value)
    return True


def _normalize_port_label(value: Any) -> Optional[str]:
    if value is None:
        return None
    text = str(value).strip()
    return text or None


def _extract_port_number(label: Optional[str]) -> Optional[int]:
    if not label:
        return None
    digits = "".join(ch if ch.isdigit() else " " for ch in label)
    try:
        parts = [int(part) for part in digits.split() if part]
    except ValueError:
        return None
    if not parts:
        return None
    # Assume the last numeric segment represents the port number
    return parts[-1]


def _collect_port_overrides(device: Dict[str, Any]) -> List[OverrideEntry]:
    entries: List[OverrideEntry] = []
    port_overrides = device.get("port_overrides")
    if isinstance(port_overrides, list):
        for idx, item in enumerate(port_overrides):
            if not isinstance(item, dict):
                continue
            label = _normalize_port_label(
                item.get("port_id") or item.get("name") or item.get("port") or item.get("port_name")
            )
            entries.append(
                OverrideEntry(
                    path=f"port_overrides[{idx}]",
                    port_label=label,
                    port_number=_extract_port_number(label),
                )
            )
    elif isinstance(port_overrides, dict):
        for key, value in port_overrides.items():
            if not _has_value(value):
                continue
            label = _normalize_port_label(key)
            entries.append(
                OverrideEntry(
                    path=f"port_overrides.{key}",
                    port_label=label,
                    port_number=_extract_port_number(label),
                )
            )
    return entries


def _is_access_switch(device: Dict[str, Any]) -> bool:
    role_candidates: Sequence[Any] = (
        device.get("role"),
        device.get("device_profile"),
        device.get("device_profile_name"),
        device.get("profile"),
        device.get("template"),
    )
    for value in role_candidates:
        if isinstance(value, str) and "access" in value.lower():
            return True
    tags = device.get("tags")
    if isinstance(tags, (list, tuple, set)):
        for tag in tags:
            if isinstance(tag, str) and "access" in tag.lower():
                return True
    return False


def _is_switch(device: Dict[str, Any]) -> bool:
    """Best-effort heuristic to determine whether a device is a switch."""

    type_hints: Sequence[Any] = (
        device.get("type"),
        device.get("device_type"),
        device.get("category"),
        device.get("role"),
        device.get("device_profile"),
        device.get("device_profile_name"),
    )
    for value in type_hints:
        if isinstance(value, str):
            lowered = value.lower()
            if "switch" in lowered:
                return True
            if lowered in {"access", "distribution", "core", "wan"}:
                return True
    model = device.get("model")
    if isinstance(model, str) and "switch" in model.lower():
        return True
    return False


def _is_access_point(device: Dict[str, Any]) -> bool:
    """Return True when the device appears to be an access point/AP."""

    type_hints: Sequence[Any] = (
        device.get("type"),
        device.get("device_type"),
        device.get("category"),
        device.get("role"),
        device.get("device_profile"),
        device.get("device_profile_name"),
    )
    for value in type_hints:
        if isinstance(value, str) and "ap" in value.lower():
            return True
    model = device.get("model")
    if isinstance(model, str) and "ap" in model.lower():
        return True
    return False


def _extract_firmware_version(device: Mapping[str, Any]) -> str:
    """Return a firmware version string from a device payload when possible."""

    candidates: Sequence[Any] = (
        device.get("firmware_version"),
        device.get("version"),
        device.get("ap_fw_version"),
        device.get("sw_version"),
    )
    for value in candidates:
        if isinstance(value, str) and value.strip():
            return value.strip()
    details = device.get("details")
    if isinstance(details, Mapping):
        nested = details.get("version")
        if isinstance(nested, str) and nested.strip():
            return nested.strip()
    return ""


def _is_device_online(device: Dict[str, Any]) -> bool:
    """Return True when the device appears to be online/connected."""

    online_tokens = ("connected", "online", "up", "ready")
    offline_tokens = ("disconnected", "offline", "down", "not connected", "not-connected")

    def interpret_status_value(value: Any) -> Optional[bool]:
        if isinstance(value, bool):
            return value
        if isinstance(value, (int, float)):
            if value == 1:
                return True
            if value == 0:
                return False
            return None
        if isinstance(value, str):
            lower = value.strip().lower()
            if not lower:
                return None
            for token in offline_tokens:
                if token in lower:
                    return False
            for token in online_tokens:
                if re.search(rf"\b{re.escape(token)}\b", lower):
                    return True
            return None
        return None

    def iter_status_values(value: Any):
        stack: List[Any] = [value]
        while stack:
            current = stack.pop()
            if isinstance(current, dict):
                stack.extend(current.values())
            elif isinstance(current, (list, tuple, set)):
                stack.extend(current)
            else:
                yield current

    candidates: List[Any] = []
    primary_status = device.get("status")
    if primary_status is not None:
        candidates.append(primary_status)
    for key in (
        "connection_state",
        "connection",
        "connectivity",
        "device_status",
        "mgmt_connection",
        "management_connection",
        "oper_status",
        "operational_status",
        "state",
        "link_state",
        "online",
        "connected",
        "ready",
        "up",
        "is_online",
    ):
        if key in device:
            candidates.append(device.get(key))

    for key, value in device.items():
        if isinstance(key, str):
            lowered = key.lower()
            if lowered.endswith("_status") or lowered.endswith("_state"):
                candidates.append(value)

    for candidate in candidates:
        for value in iter_status_values(candidate):
            result = interpret_status_value(value)
            if result is True:
                return True
    return False



def _extract_device_switch_config(device: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    keys = (
        "switch_config",
        "config",
        "configuration",
        "switch",
        "device_config",
    )
    for key in keys:
        value = device.get(key)
        if isinstance(value, dict):
            return value
    for key in ("data", "details", "template"):
        nested = device.get(key)
        if isinstance(nested, dict):
            value = _extract_device_switch_config(nested)
            if value is not None:
                return value
    return None


def _extract_switch_template_config(container: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    keys = (
        "switch_config",
        "config",
        "configuration",
        "switch",
        "device_config",
    )
    for key in keys:
        value = container.get(key)
        if isinstance(value, dict):
            return value
    for key in ("template", "data", "definition"):
        nested = container.get(key)
        if isinstance(nested, dict):
            value = _extract_switch_template_config(nested)
            if value is not None:
                return value
    return None


@dataclass
class SwitchTemplateInfo:
    template_id: Optional[str]
    name: Optional[str]
    config: Dict[str, Any]


def _gather_switch_templates(context: SiteContext) -> List[SwitchTemplateInfo]:
    templates: List[SwitchTemplateInfo] = []
    containers: List[Dict[str, Any]] = []

    if isinstance(context.setting, dict):
        containers.append(context.setting)
    containers.extend([tpl for tpl in context.templates if isinstance(tpl, dict)])

    seen: Set[Tuple[Optional[str], Optional[str]]] = set()
    for container in containers:
        config = _extract_switch_template_config(container)
        if not config:
            continue
        template_id = None
        for key in ("template_id", "id", "networktemplate_id", "switch_template_id"):
            value = container.get(key)
            if value is None:
                continue
            template_id = str(value)
            break
        name = None
        for key in ("name", "template_name", "networktemplate_name"):
            value = container.get(key)
            if isinstance(value, str) and value.strip():
                name = value
                break
        identity = (template_id, name)
        if identity in seen:
            continue
        seen.add(identity)
        templates.append(SwitchTemplateInfo(template_id=template_id, name=name, config=config))
    return templates


def _candidate_template_identifiers(device: Dict[str, Any]) -> Tuple[List[str], List[str]]:
    id_candidates: List[str] = []
    name_candidates: List[str] = []
    for key in (
        "switch_template_id",
        "template_id",
        "networktemplate_id",
        "network_template_id",
        "device_template_id",
    ):
        value = device.get(key)
        if value is None:
            continue
        text = str(value).strip()
        if text:
            id_candidates.append(text)
    for key in (
        "switch_template",
        "switch_template_name",
        "template",
        "template_name",
        "networktemplate_name",
    ):
        value = device.get(key)
        if isinstance(value, str):
            text = value.strip()
            if text:
                name_candidates.append(text)
    return id_candidates, name_candidates


def _resolve_switch_template(
    device: Dict[str, Any], templates: Sequence[SwitchTemplateInfo]
) -> Optional[SwitchTemplateInfo]:
    if not templates:
        return None
    id_candidates, name_candidates = _candidate_template_identifiers(device)
    for candidate in id_candidates:
        for template in templates:
            if template.template_id and template.template_id == candidate:
                return template
    for candidate in name_candidates:
        for template in templates:
            if template.name and template.name == candidate:
                return template
    if len(templates) == 1:
        return templates[0]
    return None


IGNORED_CONFIG_KEYS: Set[str] = {
    "id",
    "uuid",
    "mac",
    "serial",
    "last_modified",
    "modified",
    "updated",
    "updated_at",
    "updated_time",
    "created",
    "created_at",
    "created_time",
    "last_seen",
    "timestamp",
    "version",
}

ALLOWED_ADDITIONAL_CONFIG_KEYS: Set[str] = {"image1_url", "image2_url", "image3_url"}

WAN_ROLE_KEYWORDS: Tuple[str, ...] = ("wan",)
WAN_ALLOWED_CONFIG_PATH_PREFIXES: Tuple[str, ...] = (
    "mgmt_ip_config",
    "mgmt_port_config",
    "mgmt_interface_config",
    "oob_ip_config",
    "oob_port_config",
    "oob_interface_config",
)


def _diff_configs(
    expected: Any,
    actual: Any,
    path: str = "",
    *,
    ignore_keys: Optional[Set[str]] = None,
) -> List[Dict[str, Any]]:
    ignore_keys = ignore_keys or set()

    if isinstance(expected, dict) and isinstance(actual, dict):
        diffs: List[Dict[str, Any]] = []
        for key, exp_value in expected.items():
            if key in ignore_keys:
                continue
            new_path = f"{path}.{key}" if path else str(key)
            if key not in actual:
                diffs.append({"path": new_path, "expected": exp_value, "actual": None})
                continue
            diffs.extend(
                _diff_configs(
                    exp_value,
                    actual[key],
                    new_path,
                    ignore_keys=ignore_keys,
                )
            )
        for key, act_value in actual.items():
            if key in ignore_keys:
                continue
            if key in expected:
                continue
            new_path = f"{path}.{key}" if path else str(key)
            diffs.append({"path": new_path, "expected": None, "actual": act_value})
        return diffs
    if isinstance(expected, list) and isinstance(actual, list):
        diffs: List[Dict[str, Any]] = []
        length = max(len(expected), len(actual))
        for idx in range(length):
            new_path = f"{path}[{idx}]" if path else f"[{idx}]"
            if idx >= len(expected):
                diffs.append({"path": new_path, "expected": None, "actual": actual[idx]})
            elif idx >= len(actual):
                diffs.append({"path": new_path, "expected": expected[idx], "actual": None})
            else:
                diffs.extend(
                    _diff_configs(
                        expected[idx],
                        actual[idx],
                        new_path,
                        ignore_keys=ignore_keys,
                    )
                )
        return diffs
    if expected != actual:
        return [
            {
                "path": path or ".",
                "expected": expected,
                "actual": actual,
            }
        ]
    return []


def _evaluate_wan_oob_ip_config(actual: Any) -> List[Dict[str, Any]]:
    diffs: List[Dict[str, Any]] = []

    def _make_diff(path: str, expected: Any, value: Any) -> Dict[str, Any]:
        diff: Dict[str, Any] = {
            "path": path,
            "expected": expected,
            "actual": value,
            "wan_oob_validation": True,
        }
        return diff

    if actual is None:
        diffs.append(
            _make_diff(
                "oob_ip_config",
                "defined static out-of-band management configuration",
                actual,
            )
        )
        return diffs

    if not isinstance(actual, dict):
        diffs.append(
            _make_diff(
                "oob_ip_config",
                "dictionary of out-of-band management configuration values",
                actual,
            )
        )
        return diffs

    type_value = actual.get("type") or actual.get("ip_assignment")
    type_normalized = str(type_value).strip().lower() if isinstance(type_value, (str, bytes)) else None
    if type_normalized != "static":
        diffs.append(
            _make_diff(
                "oob_ip_config.type",
                "static",
                type_value,
            )
        )

    for key in ("ip", "netmask", "gateway"):
        value = actual.get(key)
        if not (isinstance(value, str) and value.strip()):
            diffs.append(
                _make_diff(
                    f"oob_ip_config.{key}",
                    "defined value",
                    value,
                )
            )

    use_mgmt_vrf = actual.get("use_mgmt_vrf")
    if use_mgmt_vrf is not True:
        diffs.append(
            _make_diff(
                "oob_ip_config.use_mgmt_vrf",
                True,
                use_mgmt_vrf,
            )
        )

    use_mgmt_host_out = actual.get("use_mgmt_vrf_for_host_out")
    if use_mgmt_host_out is not False:
        diffs.append(
            _make_diff(
                "oob_ip_config.use_mgmt_vrf_for_host_out",
                False,
                use_mgmt_host_out,
            )
        )

    return diffs
def _role_scoped_switch_configs(
    role: Any,
    template_config: Dict[str, Any],
    device_config: Dict[str, Any],
) -> Tuple[Dict[str, Any], Dict[str, Any], Any, Any]:
    expected_trimmed: Dict[str, Any] = copy.deepcopy(template_config)
    actual_trimmed: Dict[str, Any] = copy.deepcopy(device_config)

    expected_ip = expected_trimmed.pop("ip_config", None)
    actual_ip = actual_trimmed.pop("ip_config", None)

    expected_trimmed.pop("port_config", None)
    actual_trimmed.pop("port_config", None)

    return expected_trimmed, actual_trimmed, expected_ip, actual_ip


def _diff_path_port_number(path: str) -> Optional[int]:
    match = re.search(r"(?:port|ports|ge-|xe-|et-).*?(\d+)$", path.lower())
    if match:
        try:
            return int(match.group(1))
        except ValueError:
            return None
    tokens = re.findall(r"(\d+)", path)
    for token in reversed(tokens):
        try:
            return int(token)
        except ValueError:
            continue
    return None


def _evaluate_ip_config(expected: Any, actual: Any) -> List[Dict[str, Any]]:
    diffs: List[Dict[str, Any]] = []

    if actual is None:
        diffs.append({
            "path": "ip_config",
            "expected": expected or "defined static IP configuration",
            "actual": actual,
        })
        return diffs

    if not isinstance(actual, dict):
        diffs.append({
            "path": "ip_config",
            "expected": "dictionary of IP configuration values",
            "actual": actual,
        })
        return diffs

    expected_type = None
    expected_network = None
    if isinstance(expected, dict):
        expected_type = expected.get("type")
        expected_network = expected.get("network")

    actual_type = actual.get("type")
    target_type = expected_type or "static"
    if actual_type != target_type:
        diffs.append({
            "path": "ip_config.type",
            "expected": target_type,
            "actual": actual_type,
        })

    actual_ip = actual.get("ip")
    if not (isinstance(actual_ip, str) and actual_ip.startswith("10.")):
        diffs.append({
            "path": "ip_config.ip",
            "expected": "address beginning with '10.'",
            "actual": actual_ip,
        })

    actual_gateway = actual.get("gateway")
    if not (isinstance(actual_gateway, str) and actual_gateway.startswith("10.")):
        diffs.append({
            "path": "ip_config.gateway",
            "expected": "gateway beginning with '10.'",
            "actual": actual_gateway,
        })

    actual_network = actual.get("network")
    target_network = expected_network or "IT_Mgmt"
    if target_network and actual_network != target_network:
        diffs.append({
            "path": "ip_config.network",
            "expected": target_network,
            "actual": actual_network,
        })

    if "netmask" not in actual:
        diffs.append({
            "path": "ip_config.netmask",
            "expected": "defined netmask",
            "actual": actual.get("netmask"),
        })

    allowed_ip_keys = {"type", "ip", "netmask", "network", "gateway"}
    for key in sorted(actual.keys()):
        if key in allowed_ip_keys:
            continue
        diffs.append({
            "path": f"ip_config.{key}",
            "expected": None,
            "actual": actual.get(key),
        })

    return diffs


def _collect_standard_device_issues(device: Dict[str, Any]) -> List[Dict[str, Any]]:
    diffs: List[Dict[str, Any]] = []

    role = device.get("role")
    if not (isinstance(role, str) and role.strip()):
        diffs.append({
            "path": "role",
            "expected": "non-empty role",
            "actual": role,
        })

    st_ip_base = device.get("st_ip_base")
    if st_ip_base not in (None, ""):
        diffs.append({
            "path": "st_ip_base",
            "expected": "empty string",
            "actual": st_ip_base,
        })

    for key in ("evpn_scope", "evpntopo_id", "deviceprofile_id", "bundled_mac"):
        value = device.get(key)
        if value not in (None, ""):
            diffs.append({
                "path": key,
                "expected": None,
                "actual": value,
            })

    return diffs


class ConfigurationOverridesCheck(ComplianceCheck):
    id = "configuration_overrides"
    name = "Configuration overrides"
    description = "Report site or device configuration overrides outside of approved exceptions."
    severity = "warning"

    allowed_access_port_max: int = 47

    def run(self, context: SiteContext) -> List[Finding]:
        findings: List[Finding] = []

        site_override_paths = _collect_override_paths(context.setting)
        if site_override_paths:
            findings.append(
                Finding(
                    site_id=context.site_id,
                    site_name=context.site_name,
                    message="Site configuration has overrides defined.",
                    details={"paths": sorted(site_override_paths)},
                )
            )

        template_names = _collect_template_names(context)
        template_ids = _collect_template_ids(context)
        site_variables = _collect_site_variables(context)
        template_details = _expected_template_details(context.site_name)
        allowed_template_names: Sequence[str] = template_details["allowed_template_names"]
        allowed_template_ids: Sequence[str] = template_details["allowed_template_ids"]
        site_type_label: str = template_details["site_type"]
        preferred_template_name: str = template_details["preferred_template_name"]
        required_dns_labels = [
            label
            for label in (
                _format_dns_var_group_label(group)
                for group in DNS_OVERRIDE_REQUIRED_VAR_GROUPS
            )
            if label
        ]
        dns_variables_defined, missing_dns_labels = _evaluate_dns_variable_groups(site_variables)

        templates = _gather_switch_templates(context)

        for device in context.devices:
            if not isinstance(device, dict):
                continue
            if not _is_switch(device):
                continue
            device_id = str(device.get("id")) if device.get("id") is not None else None
            device_name = _normalize_site_name(device) or device_id or "device"
            role_value = device.get("role")
            role_lower = role_value.lower() if isinstance(role_value, str) else ""
            is_wan_role = bool(role_lower and any(token in role_lower for token in WAN_ROLE_KEYWORDS))

            # Non-port overrides (e.g., config_override)
            direct_paths = [path for path in _collect_override_paths(device) if not path.startswith("port_overrides")]
            for path in direct_paths:
                findings.append(
                    Finding(
                        site_id=context.site_id,
                        site_name=context.site_name,
                        device_id=device_id,
                        device_name=device_name,
                        message="Device has configuration overrides defined.",
                        details={"paths": [path]},
                    )
                )

            # Port overrides with exception logic
            port_overrides = _collect_port_overrides(device)
            access_switch = _is_access_switch(device)
            port_override_allowed_paths: Set[str] = set()
            if port_overrides:
                for entry in port_overrides:
                    if access_switch and entry.port_number is not None and 0 <= entry.port_number <= self.allowed_access_port_max:
                        continue
                    findings.append(
                        Finding(
                            site_id=context.site_id,
                            site_name=context.site_name,
                            device_id=device_id,
                            device_name=device_name,
                            message="Device port override detected.",
                            details={
                                "path": entry.path,
                                "port": entry.port_label,
                                "port_number": entry.port_number,
                                "access_switch": access_switch,
                            },
                        )
                    )
                port_override_allowed_paths = {entry.path for entry in port_overrides}

            template = _resolve_switch_template(device, templates)
            expected_config_raw = template.config if template else None
            actual_config_raw = _extract_device_switch_config(device)
            if expected_config_raw and not isinstance(expected_config_raw, dict):
                expected_config_raw = None
            actual_config_source: Optional[Dict[str, Any]]
            if isinstance(actual_config_raw, dict):
                actual_config_source = actual_config_raw
            elif isinstance(device, dict):
                actual_config_source = {k: v for k, v in device.items() if isinstance(k, str)}
            else:
                actual_config_source = None

            expected_ip_config = None
            actual_ip_config = None

            actual_oob_config = None
            if isinstance(actual_config_source, dict):
                actual_oob_config = actual_config_source.get("oob_ip_config")
            if actual_oob_config is None and isinstance(device, dict):
                actual_oob_config = device.get("oob_ip_config")

            if expected_config_raw and actual_config_source:
                (
                    filtered_expected,
                    filtered_actual,
                    expected_ip_config,
                    actual_ip_config,
                ) = _role_scoped_switch_configs(
                    role_value,
                    expected_config_raw,
                    actual_config_source,
                )
                if filtered_expected or filtered_actual:
                    diffs = _diff_configs(
                        filtered_expected,
                        filtered_actual,
                        ignore_keys=IGNORED_CONFIG_KEYS | ALLOWED_ADDITIONAL_CONFIG_KEYS,
                    )
                else:
                    diffs = []
            else:
                diffs = []

            if actual_ip_config is None and isinstance(actual_config_source, dict):
                actual_ip_config = actual_config_source.get("ip_config")
            if expected_ip_config is None and isinstance(expected_config_raw, dict):
                expected_ip_config = expected_config_raw.get("ip_config")

            ip_config_diffs: List[Dict[str, Any]] = []
            wan_oob_diffs: List[Dict[str, Any]] = []
            if expected_config_raw or actual_config_source:
                ip_config_diffs = _evaluate_ip_config(
                    expected_ip_config if expected_config_raw else None,
                    actual_ip_config if actual_config_source else None,
                )
            if is_wan_role:
                wan_oob_diffs = _evaluate_wan_oob_ip_config(actual_oob_config)
                ip_config_diffs = []

            standard_device_diffs = _collect_standard_device_issues(device)

            combined_diffs = []
            if diffs:
                combined_diffs.extend(diffs)
            if ip_config_diffs:
                combined_diffs.extend(ip_config_diffs)
            if standard_device_diffs:
                combined_diffs.extend(standard_device_diffs)

            if wan_oob_diffs:
                combined_diffs.extend(wan_oob_diffs)

            if combined_diffs:
                filtered_diffs: List[Dict[str, Any]] = []
                for diff in combined_diffs:
                    path = diff.get("path") or ""
                    normalized_path = path.lower()
                    if is_wan_role and not diff.get("wan_oob_validation") and any(
                        normalized_path.startswith(prefix)
                        for prefix in WAN_ALLOWED_CONFIG_PATH_PREFIXES
                    ):
                        continue
                    if any(path.startswith(p) for p in port_override_allowed_paths):
                        continue
                    filtered_diffs.append(diff)
                if filtered_diffs:
                    actions: Optional[List[Dict[str, Any]]] = None
                    if device_id:
                        dns_diff = next(
                            (
                                diff
                                for diff in filtered_diffs
                                if isinstance(diff, dict)
                                and (diff.get("path") or "").lower() == "ip_config.dns"
                            ),
                            None,
                        )
                        if dns_diff is not None:
                            actual_dns = dns_diff.get("actual") if isinstance(dns_diff, dict) else None
                            expected_dns = dns_diff.get("expected") if isinstance(dns_diff, dict) else None
                            if expected_dns in (None, [], (), "") and isinstance(actual_dns, list):
                                dns_values = [
                                    str(value).strip()
                                    for value in actual_dns
                                    if isinstance(value, (str, bytes)) and str(value).strip()
                                ]
                                if dns_values:
                                    device_template_id = _resolve_device_template_id(device)
                                    template_precheck_ok = _template_matches_requirements(
                                        template_names,
                                        template_ids,
                                        allowed_template_names,
                                        allowed_template_ids,
                                        device_template_id,
                                    )
                                    precheck_messages: List[str] = []
                                    if not template_precheck_ok:
                                        precheck_messages.append(
                                            _format_template_precheck_message(allowed_template_names)
                                        )
                                    if not dns_variables_defined:
                                        if missing_dns_labels:
                                            precheck_messages.append(
                                                f"Define site DNS variables: {', '.join(missing_dns_labels)}."
                                            )
                                        else:
                                            precheck_messages.append(
                                                "Required site DNS variables are missing."
                                            )
                                    can_run = template_precheck_ok and dns_variables_defined
                                    actions = [
                                        {
                                            "id": CLEAR_DNS_OVERRIDE_ACTION_ID,
                                            "label": "Clear DNS override",
                                            "button_label": "1 Click Fix Now",
                                            "site_ids": [context.site_id],
                                            "devices": [
                                                {
                                                    "site_id": context.site_id,
                                                    "device_id": device_id,
                                                }
                                            ],
                                            "metadata": {
                                                "device_id": device_id,
                                                "device_name": device_name,
                                                "dns_values": dns_values,
                                                "prechecks": {
                                                    "can_run": can_run,
                                                    "site_type": site_type_label,
                                                    "template_applied": bool(
                                                        template_precheck_ok
                                                    ),
                                                    "template_name": preferred_template_name,
                                                    "allowed_template_names": list(
                                                        allowed_template_names
                                                    ),
                                                    "allowed_template_ids": list(
                                                        allowed_template_ids
                                                    ),
                                                    "device_template_id": device_template_id,
                                                    "dns_variables_defined": bool(
                                                        dns_variables_defined
                                                    ),
                                                    "required_dns_variables": required_dns_labels,
                                                    "missing_dns_variables": missing_dns_labels,
                                                    "messages": precheck_messages,
                                                },
                                            },
                                        }
                                    ]
                    template_label = None
                    if template:
                        template_label = template.name or template.template_id
                    findings.append(
                        Finding(
                            site_id=context.site_id,
                            site_name=context.site_name,
                            device_id=device_id,
                            device_name=device_name,
                            message="Device configuration differs from assigned template.",
                            details={
                                "diffs": filtered_diffs,
                                **({"template": template_label} if template_label else {}),
                            },
                            actions=actions,
                        )
                    )

        return findings


DEFAULT_SWITCH_NAME_PATTERN = (
    r"^(NA|LA|EU|AP)[A-Z]{3}(?:MDFSPARE|MDF(AS|CS|WS)\d+|IDF\d+(AS|CS|WS)\d+)$"
)

DEFAULT_AP_NAME_PATTERN = r"^(NA|LA|EU|AP)[A-Z]{3}(?:MDF|IDF\d+)AP\d+$"


SWITCH_LOCATION_EXTRACT_PATTERN = re.compile(
    r"^(?P<region>NA|LA|EU|AP)(?P<site>[A-Z]{3})(?P<location>MDF|IDF\d+)[A-Z]{2}\d+$"
)
AP_LOCATION_EXTRACT_PATTERN = re.compile(
    r"^(?P<region>NA|LA|EU|AP)(?P<site>[A-Z]{3})(?P<location>MDF|IDF\d+)AP\d+$"
)


DNS_OVERRIDE_TEMPLATE_NAME = "Prod - Standard Template"
DNS_OVERRIDE_LAB_TEMPLATE_NAME = "Test - Standard Template"
DNS_OVERRIDE_PROD_TEMPLATE_IDS: Tuple[str, ...] = (
    "35413d62-89d5-45f7-a5dd-9d7e2ed31a23",
)
DNS_OVERRIDE_LAB_TEMPLATE_IDS: Tuple[str, ...] = (
    "40928180-ea55-48c5-9055-f34c1fe1033a",
)
DNS_OVERRIDE_REQUIRED_VAR_GROUPS: Tuple[Tuple[str, ...], ...] = (
    ("siteDNS", "siteDNSserver"),
    ("hubDNSserver1",),
    ("hubDNSserver2",),
)
DNS_OVERRIDE_REQUIRED_VARS: Tuple[str, ...] = tuple(group[0] for group in DNS_OVERRIDE_REQUIRED_VAR_GROUPS)


def _strip_pattern_wrappers(value: str) -> str:
    """Remove optional r"..." or quoted wrappers from an env-sourced pattern."""

    if len(value) >= 3 and value[0] in {"r", "R"} and value[1] in {'"', "'"} and value[-1] == value[1]:
        return value[2:-1]
    if len(value) >= 2 and value[0] in {'"', "'"} and value[-1] == value[0]:
        return value[1:-1]
    return value


def _literal_eval_pattern(value: str) -> Optional[str]:
    """Attempt to evaluate quoted patterns such as r"^...$" into plain strings."""

    try:
        evaluated = ast.literal_eval(value)
    except (ValueError, SyntaxError):
        return None
    return evaluated if isinstance(evaluated, str) else None


def _load_pattern_from_rules(var_name: str, default: Optional[str]) -> Optional[re.Pattern[str]]:
    raw = _load_compliance_rule_value(var_name)
    candidate = (raw or "").strip()
    if candidate:
        evaluated = _literal_eval_pattern(candidate)
        if evaluated is not None:
            candidate = evaluated
        else:
            candidate = _strip_pattern_wrappers(candidate)
        try:
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", DeprecationWarning)
                candidate = candidate.encode("utf-8").decode("unicode_escape")
        except Exception:
            pass
    if not candidate:
        candidate = default or ""
    if not candidate:
        return None
    try:
        return re.compile(candidate)
    except re.error:
        if default and candidate != default:
            try:
                return re.compile(default)
            except re.error:
                return None
        return None


def _ensure_pattern(
    pattern: Optional[re.Pattern[str] | str],
    fallback: Optional[re.Pattern[str]],
) -> Optional[re.Pattern[str]]:
    if isinstance(pattern, re.Pattern):
        return pattern
    if isinstance(pattern, str):
        stripped = pattern.strip()
        if not stripped:
            return None
        try:
            return re.compile(stripped)
        except re.error:
            return fallback
    return fallback


def _load_switch_name_pattern() -> Optional[re.Pattern[str]]:
    return _load_pattern_from_rules("SWITCH_NAME_REGEX_PATTERN", DEFAULT_SWITCH_NAME_PATTERN)


def _load_ap_name_pattern() -> Optional[re.Pattern[str]]:
    return _load_pattern_from_rules("AP_NAME_REGEX_PATTERN", DEFAULT_AP_NAME_PATTERN)


NEIGHBOR_NAME_KEYS: Tuple[str, ...] = (
    "system_name",
    "sys_name",
    "name",
    "remote_system_name",
    "lldp_remote_system_name",
)


def _is_plausible_neighbor_name(value: str) -> bool:
    text = value.strip()
    if not text:
        return False
    if SWITCH_LOCATION_EXTRACT_PATTERN.match(text):
        return True
    # Allow custom switch patterns that still expose MDF/IDF tokens
    return bool(re.search(r"IDF\d+|MDF", text))


def _extract_name_from_mapping(data: Mapping[str, Any]) -> Optional[str]:
    for key in NEIGHBOR_NAME_KEYS:
        value = data.get(key)
        if isinstance(value, str) and _is_plausible_neighbor_name(value):
            return value.strip()
    # Some APIs return the neighbor directly as a string value
    if isinstance(data.get("neighbor"), str) and _is_plausible_neighbor_name(data["neighbor"]):
        return data["neighbor"].strip()
    return None


def _search_neighbor_tree(value: Any, visited: Optional[Set[int]] = None) -> Optional[str]:
    if visited is None:
        visited = set()
    obj_id = id(value)
    if obj_id in visited:
        return None
    visited.add(obj_id)

    if isinstance(value, Mapping):
        direct = _extract_name_from_mapping(value)
        if direct:
            return direct

        # Prioritise typical neighbor containers first
        for key in (
            "neighbor",
            "neighbors",
            "uplink",
            "uplinks",
            "lldp",
            "lldp_stats",
            "ports",
            "interfaces",
            "wired",
            "wired_interfaces",
            "wired_ports",
        ):
            if key in value:
                result = _search_neighbor_tree(value[key], visited)
                if result:
                    return result

        for nested in value.values():
            result = _search_neighbor_tree(nested, visited)
            if result:
                return result

    elif isinstance(value, (list, tuple, set)):
        for item in value:
            result = _search_neighbor_tree(item, visited)
            if result:
                return result
    elif isinstance(value, str) and _is_plausible_neighbor_name(value):
        return value.strip()
    return None


def _neighbor_system_name_from_stats(stats: Mapping[str, Any]) -> Optional[str]:
    if not isinstance(stats, Mapping):
        return None

    # Common top-level keys returned by Mist device stats APIs
    for key in ("uplink", "lldp", "lldp_stats", "ports", "interfaces"):
        if key in stats:
            result = _search_neighbor_tree(stats.get(key))
            if result:
                return result

    return _search_neighbor_tree(stats)


def _extract_neighbor_system_name(device: Mapping[str, Any]) -> Optional[str]:
    candidates: List[Mapping[str, Any]] = []

    for key in ("stats", "device_stats", "stat", "status"):
        value = device.get(key)
        if isinstance(value, Mapping):
            candidates.append(value)

    lldp_value = device.get("lldp_stats")
    if isinstance(lldp_value, Mapping):
        candidates.append(lldp_value)
    elif isinstance(lldp_value, (list, tuple, set)):
        candidates.append({"lldp_stats": lldp_value})

    uplink_value = device.get("uplink")
    if isinstance(uplink_value, Mapping):
        candidates.append({"uplink": uplink_value})

    for stats in candidates:
        neighbor = _neighbor_system_name_from_stats(stats)
        if neighbor:
            return neighbor
    return None


def _parse_switch_location(
    name: str, pattern: Optional[re.Pattern[str]]
) -> Optional[Tuple[str, str, str]]:
    text = (name or "").strip()
    if not text:
        return None
    if pattern is not None and pattern.fullmatch(text) is None:
        return None
    match = SWITCH_LOCATION_EXTRACT_PATTERN.match(text)
    if not match:
        return None
    return match.group("region"), match.group("site"), match.group("location")


def _parse_ap_location(
    name: str, pattern: Optional[re.Pattern[str]]
) -> Optional[Tuple[str, str, str]]:
    text = (name or "").strip()
    if not text:
        return None
    if pattern is not None and pattern.fullmatch(text) is None:
        return None
    match = AP_LOCATION_EXTRACT_PATTERN.match(text)
    if not match:
        return None
    return match.group("region"), match.group("site"), match.group("location")


def _load_positive_int_from_rules(var_name: str, default: int) -> int:
    raw = _load_compliance_rule_value(var_name)
    if raw is None:
        return default
    candidate = raw.strip()
    if not candidate:
        return default
    try:
        value = int(candidate)
        if value < 0:
            return default
        return value
    except ValueError:
        return default


def _load_switch_image_requirement() -> int:
    return _load_positive_int_from_rules("SW_NUM_IMG", 2)


def _load_ap_image_requirement() -> int:
    return _load_positive_int_from_rules("AP_NUM_IMG", 2)


class FirmwareManagementCheck(ComplianceCheck):
    id = "firmware_management"
    name = "Firmware Management"
    description = "Ensure switches and access points run approved firmware versions."
    severity = "warning"

    def __init__(
        self,
        allowed_switch_versions: Optional[Sequence[str]] = None,
        allowed_ap_versions: Optional[Sequence[str]] = None,
    ) -> None:
        if allowed_switch_versions is None:
            allowed_switch_versions = _load_version_list_from_rules("STD_SW_VER")
        if allowed_ap_versions is None:
            allowed_ap_versions = _load_version_list_from_rules("STD_AP_VER")
        self.allowed_switch_versions: Tuple[str, ...] = tuple(allowed_switch_versions or ())
        self.allowed_ap_versions: Tuple[str, ...] = tuple(allowed_ap_versions or ())
        self._allowed_switch_set = {value for value in self.allowed_switch_versions}
        self._allowed_ap_set = {value for value in self.allowed_ap_versions}

    def run(self, context: SiteContext) -> List[Finding]:
        if not self.allowed_switch_versions and not self.allowed_ap_versions:
            return []

        findings: List[Finding] = []
        for device in context.devices:
            if not isinstance(device, Mapping):
                continue

            device_dict = device if isinstance(device, dict) else dict(device)

            device_type: Optional[str] = None
            allowed_versions: Tuple[str, ...]
            allowed_set: Set[str]

            if self.allowed_switch_versions and _is_switch(device_dict):
                device_type = "Switch"
                allowed_versions = self.allowed_switch_versions
                allowed_set = self._allowed_switch_set
            elif self.allowed_ap_versions and _is_access_point(device_dict):
                device_type = "Access point"
                allowed_versions = self.allowed_ap_versions
                allowed_set = self._allowed_ap_set
            else:
                continue

            version = _extract_firmware_version(device_dict) or ""
            is_allowed = bool(version) and version in allowed_set
            if is_allowed:
                continue

            device_id = str(device_dict.get("id")) if device_dict.get("id") is not None else None
            name_candidates: Sequence[Any] = (
                device_dict.get("name"),
                device_dict.get("hostname"),
                device_dict.get("device_name"),
                device_dict.get("mac"),
                device_id,
            )
            device_name = next(
                (str(value).strip() for value in name_candidates if isinstance(value, str) and value.strip()),
                None,
            )
            if not device_name:
                device_name = device_id or device_type or "device"

            allowed_text = ", ".join(allowed_versions)
            if version:
                message = (
                    f"{device_type} '{device_name}' is running firmware version '{version}' "
                    f"which is not in the approved list ({allowed_text})."
                )
            else:
                message = (
                    f"{device_type} '{device_name}' does not report a firmware version. "
                    f"Approved versions: {allowed_text}."
                )

            details = {
                "device_type": device_type,
                "model": device_dict.get("model"),
                "version": version or None,
                "allowed_versions": list(allowed_versions),
            }

            findings.append(
                Finding(
                    site_id=context.site_id,
                    site_name=context.site_name,
                    device_id=device_id,
                    device_name=device_name,
                    message=message,
                    details=details,
                )
            )

        return findings


class DeviceNamingConventionCheck(ComplianceCheck):
    id = "device_naming_convention"
    name = "Device naming convention"
    description = "Ensure device names follow the configured naming convention."
    severity = "warning"

    def __init__(
        self,
        switch_pattern: Optional[re.Pattern[str] | str] = None,
        ap_pattern: Optional[re.Pattern[str] | str] = None,
    ) -> None:
        self.switch_pattern = _ensure_pattern(switch_pattern, _load_switch_name_pattern())
        self.ap_pattern = _ensure_pattern(ap_pattern, _load_ap_name_pattern())
        self.prepare_run()

    def prepare_run(self) -> None:
        self._ap_issue_counts: Dict[str, int] = {}
        self._ap_issue_sites: Dict[str, str] = {}

    def _build_ap_rename_action(
        self, context: SiteContext, device_id: Optional[str], device_name: str
    ) -> Optional[List[Dict[str, Any]]]:
        if not device_id or not self.ap_pattern:
            return None
        return [
            {
                "id": AP_RENAME_ACTION_ID,
                "label": "Rename access point",
                "button_label": "1 Click Fix Now",
                "site_ids": [context.site_id],
                "devices": [
                    {
                        "site_id": context.site_id,
                        "device_id": device_id,
                    }
                ],
                "metadata": {
                    "device_id": device_id,
                    "current_name": device_name or "",
                    "expected_pattern": self.ap_pattern.pattern,
                },
            }
        ]

    def _check_ap_switch_alignment(
        self, device: Mapping[str, Any], device_name: str
    ) -> Optional[Tuple[str, Dict[str, Any]]]:
        neighbor = _extract_neighbor_system_name(device)
        if not neighbor:
            return None

        ap_tokens = _parse_ap_location(device_name, self.ap_pattern)
        if not ap_tokens:
            return None

        switch_tokens = _parse_switch_location(neighbor, self.switch_pattern)
        if not switch_tokens:
            return None

        ap_region, ap_site, ap_location = ap_tokens
        sw_region, sw_site, sw_location = switch_tokens

        mismatches: List[Tuple[str, str, str]] = []
        if (ap_region, ap_site) != (sw_region, sw_site):
            mismatches.append(("site", f"{ap_region}{ap_site}", f"{sw_region}{sw_site}"))
        if ap_location != sw_location:
            mismatches.append(("location", ap_location, sw_location))

        if not mismatches:
            return None

        parts: List[str] = []
        for category, ap_value, sw_value in mismatches:
            label = "site prefix" if category == "site" else "location token"
            parts.append(f"{label} '{ap_value}' vs '{sw_value}'")
        difference_text = "; ".join(parts)

        message = (
            "Access point name does not match uplink switch "
            f"'{neighbor}' ({difference_text})."
        )
        details = {
            "neighbor": neighbor,
            "ap_name": device_name,
            "ap_region": ap_region,
            "ap_site": ap_site,
            "ap_location": ap_location,
            "switch_region": sw_region,
            "switch_site": sw_site,
            "switch_location": sw_location,
            "mismatches": [
                {"type": category, "ap": ap_value, "switch": sw_value}
                for category, ap_value, sw_value in mismatches
            ],
        }
        return message, details

    def _register_ap_issue(self, context: SiteContext, device_name: str) -> None:
        site_id = context.site_id
        self._ap_issue_counts[site_id] = self._ap_issue_counts.get(site_id, 0) + 1
        if site_id not in self._ap_issue_sites:
            label = context.site_name or site_id
            self._ap_issue_sites[site_id] = label

    def run(self, context: SiteContext) -> List[Finding]:
        findings: List[Finding] = []
        for device in context.devices:
            if not isinstance(device, dict):
                continue

            pattern: Optional[re.Pattern[str]] = None
            label = "Device"
            is_ap = False
            if _is_switch(device):
                pattern = self.switch_pattern
                label = "Switch"
            elif _is_access_point(device):
                pattern = self.ap_pattern
                label = "Access point"
                is_ap = True

            if pattern is None:
                continue

            device_id = str(device.get("id")) if device.get("id") is not None else None
            device_name = (
                (device.get("name") or device.get("hostname") or device.get("device_name") or "")
                .strip()
            )
            if not device_name or not pattern.fullmatch(device_name):
                if label == "Switch" and pattern.pattern == DEFAULT_SWITCH_NAME_PATTERN:
                    message = (
                        "Switch name does not match required convention (e.g., NACHIMDFWS1, "
                        "NACHIIDF1AS3, or NACHIMDFSPARE)."
                    )
                else:
                    message = f"{label} name does not match required convention."

                actions: Optional[List[Dict[str, Any]]] = None
                if is_ap:
                    actions = self._build_ap_rename_action(context, device_id, device_name or "")
                findings.append(
                    Finding(
                        site_id=context.site_id,
                        site_name=context.site_name,
                        device_id=device_id,
                        device_name=device_name or device_id or "device",
                        message=message,
                        details={"expected_pattern": pattern.pattern},
                        actions=actions,
                    )
                )
                if is_ap:
                    self._register_ap_issue(context, device_name or (device_id or ""))
                continue

            if is_ap:
                alignment_issue = self._check_ap_switch_alignment(device, device_name)
                if alignment_issue:
                    message, details = alignment_issue
                    actions = self._build_ap_rename_action(context, device_id, device_name)
                    findings.append(
                        Finding(
                            site_id=context.site_id,
                            site_name=context.site_name,
                            device_id=device_id,
                            device_name=device_name,
                            message=message,
                            details=details,
                            actions=actions,
                        )
                    )
                    self._register_ap_issue(context, device_name)
        return findings

    def suggest_actions(
        self,
        contexts: Sequence[SiteContext],
        findings: Sequence[Finding],
    ) -> List[Dict[str, Any]]:
        return []


def _collect_device_images(device: Dict[str, Any]) -> List[str]:
    image_keys = ("images", "pictures", "photos", "image_urls", "image")
    image_url_pattern = re.compile(r"^image\d+_url$", re.IGNORECASE)
    images: List[str] = []

    def append_images(value: Any) -> None:
        if isinstance(value, str):
            text = value.strip()
            if text:
                images.append(text)
        elif isinstance(value, list):
            for item in value:
                append_images(item)
        elif isinstance(value, dict):
            for item in value.values():
                append_images(item)

    for key in image_keys:
        value = device.get(key)
        if value is not None:
            append_images(value)

    for key, value in device.items():
        if isinstance(key, str) and image_url_pattern.match(key):
            append_images(value)

    # Deduplicate while preserving order
    seen: Set[str] = set()
    unique_images: List[str] = []
    for url in images:
        if url not in seen:
            seen.add(url)
            unique_images.append(url)
    return unique_images


class DeviceDocumentationCheck(ComplianceCheck):
    id = "device_documentation"
    name = "Device documentation"
    description = "Ensure devices are mapped to floorplans and have required reference images."
    severity = "warning"

    def __init__(
        self,
        *,
        switch_min_images: Optional[int] = None,
        ap_min_images: Optional[int] = None,
        default_min_images: int = 2,
    ) -> None:
        def _sanitize(value: Optional[int], fallback: int) -> int:
            if value is None:
                return max(fallback, 0)
            if value < 0:
                return max(fallback, 0)
            return value

        self.switch_min_images = _sanitize(switch_min_images, _load_switch_image_requirement())
        self.ap_min_images = _sanitize(ap_min_images, _load_ap_image_requirement())
        self.default_min_images = _sanitize(default_min_images, 2)

    def run(self, context: SiteContext) -> List[Finding]:
        findings: List[Finding] = []
        for device in context.devices:
            if not isinstance(device, dict):
                continue
            device_id = str(device.get("id")) if device.get("id") is not None else None
            device_name = _normalize_site_name(device) or device_id or "device"
            map_id = device.get("map_id")
            if not map_id:
                findings.append(
                    Finding(
                        site_id=context.site_id,
                        site_name=context.site_name,
                        device_id=device_id,
                        device_name=device_name,
                        message="Device not assigned to any floorplan.",
                    )
                )
            images = _collect_device_images(device)
            required_images = self.default_min_images
            if _is_switch(device):
                required_images = self.switch_min_images
            elif _is_access_point(device):
                required_images = self.ap_min_images

            if required_images <= 0:
                continue

            if len(images) < required_images:
                findings.append(
                    Finding(
                        site_id=context.site_id,
                        site_name=context.site_name,
                        device_id=device_id,
                        device_name=device_name,
                        message=(
                            f"Required images not present (found {len(images)} of {required_images})."
                        ),
                    )
                )
        return findings


class LogicRuleComplianceCheck(ComplianceCheck):
    """Evaluate user-defined compliance rules from compliance_rules.json."""

    def __init__(self, rule: Mapping[str, Any], index: int):
        self.rule = dict(rule)
        self.id = f"logic_rule_{index}"
        name = str(rule.get("name") or "").strip()
        self.name = name or f"Custom Rule {index}"
        action_label = str(rule.get("action_label") or "").strip()
        action_path = str(rule.get("action_path") or "").strip()
        self.description = action_label or action_path or "Custom compliance rule"

    def _iter_targets(self, context: SiteContext) -> Iterable[Tuple[Mapping[str, Any], Optional[str], Optional[str]]]:
        scope = str(self.rule.get("scope") or "").strip().lower()
        action_path = str(self.rule.get("action_path") or "")
        if scope == "device" or "/devices" in action_path:
            devices = context.devices if isinstance(context.devices, Sequence) else []
            for device in devices:
                if not isinstance(device, Mapping):
                    continue
                device_id = device.get("id")
                device_name = (
                    device.get("name")
                    or device.get("hostname")
                    or device.get("device_name")
                    or device.get("mac")
                    or device.get("id")
                )
                payload = _build_device_payload(context, device)
                yield payload, str(device_id) if device_id is not None else None, (
                    str(device_name).strip() if device_name is not None else None
                )
        else:
            yield _build_site_payload(context), None, None

    def run(self, context: SiteContext) -> List[Finding]:
        findings: List[Finding] = []
        conditions = self.rule.get("conditions") or []
        if not isinstance(conditions, Sequence):
            return findings
        for payload, device_id, device_name in self._iter_targets(context):
            if not isinstance(payload, Mapping):
                continue
            if not _evaluate_conditions(conditions, payload):
                continue
            fields = {str(cond.get("field") or "") for cond in conditions if isinstance(cond, Mapping)}
            matched_fields = {
                field: _extract_field_value(payload, field) for field in fields if field
            }
            message = self.name
            if self.description:
                message = f"{message}: {self.description}"
            findings.append(
                Finding(
                    site_id=context.site_id,
                    site_name=context.site_name,
                    device_id=device_id,
                    device_name=device_name,
                    message=message,
                    details={
                        "action_id": self.rule.get("action_id"),
                        "action_label": self.rule.get("action_label"),
                        "action_path": self.rule.get("action_path"),
                        "scope": self.rule.get("scope"),
                        "matched_fields": matched_fields,
                    },
                )
            )
        return findings


class SiteAuditRunner:
    """Runs a suite of compliance checks across one or more sites."""

    def __init__(self, checks: Sequence[ComplianceCheck]):
        self.checks: List[ComplianceCheck] = list(checks)

    def run(self, contexts: Sequence[SiteContext]) -> Dict[str, Any]:
        results: List[Dict[str, Any]] = []
        total_sites = len(contexts)
        total_devices = 0
        site_devices: Dict[str, int] = {}
        for context in contexts:
            devices = context.devices
            if isinstance(devices, Sequence) and not isinstance(devices, (str, bytes)):
                count = len(devices)
                total_devices += count
            else:
                count = 0
            site_devices[context.site_id] = count
        total_findings = 0
        site_findings: Dict[str, int] = {context.site_id: 0 for context in contexts}
        total_quick_fix_issues = 0
        for check in self.checks:
            check.prepare_run()
            check_findings: List[Finding] = []
            for context in contexts:
                site_findings_for_check = check.run(context)
                check_findings.extend(site_findings_for_check)
                site_findings[context.site_id] = site_findings.get(context.site_id, 0) + len(
                    site_findings_for_check
                )
            total_findings += len(check_findings)
            for finding in check_findings:
                actions = finding.actions or []
                for action in actions:
                    if not isinstance(action, Mapping):
                        continue
                    label_value = action.get("button_label")
                    if label_value is None:
                        continue
                    label_text = str(label_value).strip().lower()
                    if label_text == "1 click fix now":
                        total_quick_fix_issues += 1
                        break
            failing_site_ids = sorted({finding.site_id for finding in check_findings})
            actions = check.suggest_actions(contexts, check_findings) or []
            results.append(
                {
                    "id": check.id,
                    "name": check.name,
                    "description": check.description,
                    "severity": check.severity,
                    "findings": [finding.as_dict(check.severity) for finding in check_findings],
                    "failing_sites": failing_site_ids,
                    "passing_sites": max(total_sites - len(failing_site_ids), 0),
                    "actions": actions,
                }
            )
        return {
            "checks": results,
            "total_sites": total_sites,
            "total_devices": total_devices,
            "total_findings": total_findings,
            "total_quick_fix_issues": total_quick_fix_issues,
            "site_findings": site_findings,
            "site_devices": site_devices,
        }


def build_default_runner() -> SiteAuditRunner:
    logic_rules = _load_logic_rules()
    checks = [
        LogicRuleComplianceCheck(rule, index + 1)
        for index, rule in enumerate(logic_rules)
    ]
    return SiteAuditRunner(checks)
